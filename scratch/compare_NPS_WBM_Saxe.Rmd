# Workflow to pull and compare NPS WBM data to Saxe et al. study

```{r}
source("setup.R")

plan(multisession)
```

## Read in Saxe et al files

```{r}
# ecoregion shapefiles
ecoregions <- read_sf("data/Saxe_etal/Ecoregions/Ecoregions.shp")

# model data
saxe_data <- read_csv("data/Saxe_etal/Ecoregion Aggregates.csv")

# retreive year range and variables included
range(saxe_data$date)
#"1900-01-01" "2018-12-01"
unique(saxe_data$component)
# "AET"   "P"     "R"     "RZSME" "RZSMV" "SWE" 
```

## Pull NPS WBM matching data

```{r}
# WBM data only goes back to 1980
historic_years <- 1980:2018
wb_var <- c("runoff", "rain", "AET", "accumswe")

map_dat <- tidyr::crossing(historic_years, wb_var)

# transform aoi to crs of WBM data
# aoi <- st_transform(aoi, crs = "+proj=lcc +lat_0=42.5 +lon_0=-100 +lat_1=25 +lat_2=60 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs")

# download each raster file to temp directory
historic_rasters <- purrr::map(1:nrow(map_dat), function(x) {
  call <- paste0(
    "/vsicurl/",
    "http://www.yellowstone.solutions/thredds/fileServer/daily_or_monthly/v2_historical/gridmet_v_1_5_historical/V_1_5_",
    map_dat$historic_years[x],
    "_gridmet_historical_",
    map_dat$wb_var[x],
    ".nc4"
  )
  
  r <- terra::rast(call)
  
  # assign informative names to each raster
  names(r) <- paste(map_dat$wb_var[x], as.Date(paste0(
    map_dat$historic_years[x], "-", sub(".*_", "", names(r))
  ), format = "%Y-%j"), sep = "_")
  
  
  return(r)
  
})


```

Clean daily rasters

```{r}
## combine all to single stack
final_historic_stack <- terra::rast(historic_rasters)

## saved CRS and extent from raw downloaded file, that info does not attach to files pulled directly from URL
crs(final_historic_stack) <- "+proj=lcc +lat_0=42.5 +lon_0=-100 +lat_1=25 +lat_2=60 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs"

ext(final_historic_stack) <- c(-2060750, 2639250, -1915500, 1384500)

```

## Calculate Ecoregion weighted averages

Follow methods from Saxe et al. script

```{r}
# project ecoregions to crs of wbm stack
eco_proj <- sf::st_transform(ecoregions, crs = terra::crs(final_historic_stack))

# test if needs rotation
## Get ecoregion extent
shp_extent <- terra::ext(eco_proj)

needs_rotation <- tryCatch({
  ddd <- terra::crop(final_historic_stack[[1]], shp_extent)
  F
}, error = function(e) {
  return(T)
})

# FALSE, good to move forward
```

Create template raster for weights

```{r}
template_raster <- final_historic_stack[[1]] %>% 
  terra::crop(shp_extent, snap = "out")

template_raster[] <- 1:raster::ncell(template_raster)
```

### Assign Weights

```{r}
# Get dimensions of template raster
template_dim <- c(nrow(template_raster), ncol(template_raster))

# Convert shapefile to list
shp_list <- split(eco_proj, 1:nrow(eco_proj))

# Extract weights by ecoregion
exx_fun <- function(xx, yy) {
  terra::extract(yy, xx, method = "bilinear", weights = T)[[1]]
}

cat("Calculating Weights\n")
cell_weights <- pbapply::pblapply(X = shp_list,
                                  FUN = exx_fun,
                                  y = template_raster,
                                  cl = NULL)

names(cell_weights) <- eco_proj$names

# Assign ecoregion names to each
cell_weights2 <- cell_weights
for (i in 1:length(cell_weights2)) {
  if (is.null(nrow(cell_weights2[[i]]))) {
    cell_weights2[[i]] <- data.frame(value = as.numeric(),
                                     weight = as.numeric(),
                                     ecoregion = as.character())
  } else{
    colnames(cell_weights2[[i]]) <- c("value", "weight")
    cell_weights2[[i]] <- as.data.frame(cell_weights2[[i]])
    cell_weights2[[i]]$ecoregion <- names(cell_weights2)[i]
  }
}

# combine into dataframe
cell_wt_df <- bind_rows(cell_weights2)
rownames(cell_wt_df) <- NULL
```

## Define extraction function

```{r}
extract_function <- function(raster_stack,
                             shp = ecoregions,
                             start_date = 1980,
                             end_date = 2018,
                             cl = NULL,
                             no_crop = F
){

  
  # Convert shapefile projection
  shp_proj <- sf::st_transform(ecoregions, crs = terra::crs(raster_stack))
  
  # Get ecoregion extent
  shp_extent <- terra::extent(shp_proj)
  
  needs_rotation <- tryCatch({
    ddd <- terra::crop(final_historic_stack[[1]], shp_extent)
    F
  }, error = function(e) {
    return(T)
  })
  
  
  # Create cell number template raster
  if (needs_rotation){
    cat("Rotation required, proceeding...\n")
    template_raster <- raster_stack[[1]]
    template_raster <- raster::rotate(template_raster)
    if (no_crop == F){
      template_raster <- terra::crop(template_raster, shp_extent, snap = "out")
    }
    template_raster[] <- 1:terra::ncell(template_raster)
  }else{
    template_raster <- raster_stack[[1]]
    if (no_crop == F){
      template_raster <- terra::crop(template_raster, shp_extent, snap = "out")
    }
    template_raster[] <- 1:terra::ncell(template_raster)
  }
  
  
  # Get dimensions of template raster
  template_dim <- c(nrow(template_raster), ncol(template_raster))
  
  # Convert shapefile to list
  shp_list <- split(shp_proj, 1:nrow(shp_proj))
  
  # Extract weights by ecoregion
  exx_fun <- function(xx, yy){ terra::extract(yy, xx, method = "bilinear", weights = T)[[1]] }
  
  cat("Calculating Weights\n")
  cell_weights <- pbapply::pblapply(X = shp_list,
                                    FUN = exx_fun,
                                    y = template_raster,
                                    cl = cl)
  names(cell_weights) <- shp_proj$names
  
  # Assign ecoregion names to each
  cell_weights2 <- cell_weights
  for (i in 1:length(cell_weights2)){
    if (is.null(nrow(cell_weights2[[i]]))){
      cell_weights2[[i]] <- data.frame(value = as.numeric(),
                                       weight = as.numeric(),
                                       ecoregion = as.character())
    }else{
      colnames(cell_weights2[[i]]) <- c("value", "weight")
      cell_weights2[[i]] <- as.data.frame(cell_weights2[[i]])
      cell_weights2[[i]]$ecoregion <- names(cell_weights2)[i]
    }
  }
  
  # combine into dataframe
  cell_wt_df <- do.call("rbind", cell_weights2)
  rownames(cell_wt_df) <- NULL
  
  ### Extract single raster function
  extract_single <- function(single_ras,
                             wts = cell_wt_df,
                             need_rot = needs_rotation,
                             ext_crop = shp_extent,
                             test_dim = template_dim,
                             do_crop  = no_crop){
    # Rotate if necessary
    if (need_rot){
      single_ras <- raster::rotate(single_ras)
    }
    # Crop to CONUS
    if (do_crop == F){
      single_ras <- terra::crop(single_ras, ext_crop, snap = "out")
    }
    # double check dimensions
    if (nrow(single_ras) != test_dim[1] || ncol(single_ras) != test_dim[2]){
      stop("Dimensions in extract function do not match template raster!")
    }
    # get values
    vals <- single_ras[][wts$value]
    # add to df
    wts$est <- vals
    # Distribute NA value weights to region
    wts_split <- split(wts, wts$ecoregion)
    wts_split <- lapply(wts_split,
                        FUN = function(x){
                          # make sure there are NAs
                          if (sum(is.na(x$est)) == 0) return(x)
                          # If all NA, just return it
                          if (sum(is.na(x$est)) == nrow(x)) return(x)
                          # extract NA weights
                          na_wts <- sum(x$weight[is.na(x$est)])
                          # if total missing values exceed 50% of region, just return complete x
                          if (na_wts >= 0.50) return(x)
                          # extract real values
                          x_real <- x[!is.na(x$est), ]
                          # calculate amount to add to each real weight
                          add_wt <- na_wts/nrow(x_real)
                          # add weights
                          x_real$weight <- x_real$weight + add_wt
                          # return
                          return(x_real)
                        })
    wts <- do.call("rbind", wts_split)
    # calculate weighted value
    wts$wted_vals <- wts$est * wts$weight
    # split by ecoregion
    wts_summed <- aggregate(wts$wted_vals, list(wts$ecoregion), FUN = sum, na.rm = F)
    # return
    return(wts_summed)
  }
  
  # Apply to each layer in stack
  raster_list <- as.list(raster_stack)
  
  cat("Extracting Values\n")
  extr_all <- pbapply::pblapply(X = raster_list,
                                FUN = extract_single,
                                wts = cell_wt_df)
  # Convert to time series
  extr_all2 <- lapply(extr_all, function(x){ x[,2] })
  extr_mat <- do.call("rbind", extr_all2)
  colnames(extr_mat) <- extr_all[[1]][,1]
  
  # Convert to zoo
  extr_zoo <- zoo::zoo(extr_mat)
  zoo::index(extr_zoo) <- dt
  
  # Return
  return(extr_zoo)
}
```
