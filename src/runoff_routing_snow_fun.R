#' This routing function is a modified IHACRES type that considers rainfall
#' and snowmelt with separate lumped runoff terms.  This function takes a 
#' dataframe containing date, rain, snowmelt, and total runoff (melt) and 
#' applies a recursive filter to partition rain into slowflow (Xsr) and 
#' quickflow (Xqs) and snowmelt into a second slowflow (Xqm). Because WBM melt
#' and rain totals don't incorporate losses from AET, they are instead used
#' to determine the fraction of total available water that is contributed from
#' melt and rain. Then, those fractions are multipled by the total runoff
#' to get an effective rain and melt contribution for each timestep.
#' 
#' This function was originally modified from the expuh function in the 
#' Hydromad R package. 
#' 
#' Andrews F, Guillaume J, Vervoort W, Buzacott A (2021). hydromad: Hydrological 
#' Model Assessment and Development. http://hydromad.catchment.org/, 
#' https://github.com/josephguillaume/hydromad.
#'       
#' @param df dataframe containing columns with date, runoff, rain, & melt
#' @param tau_q_rain Recession coefficient for rain quickflow  
#' @param tau_s_rain Recession coefficient for rain slowflow 
#' @param tau_s_melt Recession coefficient for snowmelt slowflow
#' @param vs_rain Fraction of rainfall that goes to slowflow (-)
#' @param return_components TRUE if return quick and slowflow separately
#' @param runoff_col column containing runoff timeseries
#' @param rain_col column containing rain timeseries
#' @param melt_col column containing melt timeseries
#' @param date_col column containing dates
#' Note, all parameters with time have same time unit as df$date. So, if daily,
#' then days.
#' 
runoff_routing_snow_fun <- function(df, 
                               tau_q_rain, 
                               tau_s_rain, 
                               vs_rain,
                               tau_s_melt,
                               delay,
                               return_components = FALSE,
                               runoff_col = "runoff_in_wbm",
                               rain_col = "rain_in_wbm",
                               melt_col = "melt_in_wbm",
                               date_col = "date") {

  
  # Check for missing dates
  full_dates <- seq(min(df$date), max(df$date), by = "day")
  missing_dates <- full_dates[!full_dates %in% df$date]
  
  # Fill missing dates using linear interpolation IF:
  #  <= 5 days of missing data
  if (length(missing_dates) > 0 & length(missing_dates) <= 5) {
    
    df <- data.frame(date = full_dates) %>%
      left_join(., df, by = "date") %>%
      arrange(date) %>%
      fill(!!sym(runoff_col), .direction = "downup") %>%
      fill(!!sym(melt_col), .direction = "downup") %>%
      fill(!!sym(rain_col), .direction = "downup")
    
    missing_idx <- match(missing_dates,df$date)
    
  # If > 5 days of missing data, prompt user to fill gaps first.
  } else if (length(missing_dates) > 5) {
    return("More than 5 days of missing data. Fill gaps before routing...")
  }
  
  # Calculate the fraction of runoff that is from snowmelt
  df <- df %>%
    dplyr::mutate(melt_frac = 
                    ifelse(!!sym(melt_col) + !!sym(rain_col) > 0, 
                           !!sym(melt_col) / (!!sym(melt_col) + !!sym(rain_col)),
                           0),
                  melt_runoff = melt_frac * !!sym(runoff_col),
                  rain_runoff = (1- melt_frac) * !!sym(runoff_col))
  

  stopifnot(all(c(tau_s_rain, tau_q_rain, tau_s_melt) >= 0))
  
  vq_rain <- 1-vs_rain
  
  alpha_s_rain <- exp(-1/tau_s_rain)
  alpha_q_rain <- exp(-1/tau_q_rain)
  alpha_s_melt <- exp(-1/tau_s_melt)
  
  beta_s_rain <- vs_rain*(1-alpha_s_rain)
  beta_q_rain <- vq_rain*(1-alpha_q_rain)
  beta_s_melt <- (1-alpha_s_rain)
  
  delay <- round(delay,0)
  
  Xsr_0 <- 0 
  Xqr_0 <- 0
  Xsm_0 <- 0

  Xsr <- Xqr <- Xsm <- vector(mode = "numeric", length = nrow(df))
  
  # Slow flow rain
  Xsr[] <- stats::filter(beta_s_rain * df$rain_runoff, 
                        alpha_s_rain, 
                        method = "recursive", 
                        init = Xsr_0) 
  
  # Quick flow rain
  Xqr[] <- stats::filter(beta_q_rain * df$rain_runoff, 
                          alpha_q_rain, 
                          method = "recursive", 
                          init = Xqr_0)
  
  # Slow flow melt
  Xsm[] <- stats::filter(beta_s_melt * df$melt_runoff, 
                         alpha_s_melt, 
                         method = "recursive", 
                         init = Xsm_0) 
  
  
  if (delay != 0) {
    Xsr <- lag(Xsr, delay)
    Xsr[is.na(Xsr)] <- 0
    Xqr <- lag(Xqr, delay)
    Xqr[is.na(Xqr)] <- 0
    Xsm <- lag(Xsm, delay)
    Xsm[is.na(Xsm)] <- 0
  }
  
  df_ret <- df %>%
    dplyr::select(date,melt_runoff,rain_runoff)
  
  if (length(missing_dates) >0 & length(missing_dates) <= 5) {
    Xqr <- Xqr[-missing_idx]
    Xsr <- Xsr[-missing_idx]
    Xsm <- Xsm[-missing_idx]
    df_ret <- df_ret[-missing_idx,]
  }

  Q_tot <- Xsr + Xqr + Xsm
  
  if (return_components == FALSE) {
    return(df_ret %>%
           bind_cols(Q_tot = Q_tot)
         )
  } else if (return_components == TRUE) {
      return(df_ret %>%
             bind_cols(Q_slow_rain = Xsr,
                       Q_quick_rain = Xqr,
                       Q_slow_melt = Xsm,
                       Q_tot = Q_tot)
           )
  }
    
}

